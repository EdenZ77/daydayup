想象一个高并发的 Web 服务，它使用了缓存来减轻数据库压力。

**没有 SingleFlight 时的问题（缓存击穿）：**

1. 缓存中的某个热点数据（例如 Key 为 `user_123`）突然过期。
2. 此时，瞬间有 1000 个请求都需要读取 `user_123`的数据。
3. 这 1000 个请求发现缓存中数据不存在，于是它们都会直接访问数据库。
4. 数据库瞬间收到 1000 个相同的查询请求，压力陡增，可能导致服务雪崩。

**使用 SingleFlight 后：**

1. 缓存中的 `user_123`数据过期。
2. 瞬间有 1000 个请求到达。第一个请求获取了“执行权”，去数据库查询数据。
3. 剩下的 999 个请求被 `singleflight`分组机制“拦住”，它们不再发起新的数据库查询，而是**等待**第一个请求的结果。
4. 第一个请求从数据库拿到数据后，会同时返回给这 999 个等待的请求。
5. **最终，数据库只承受了 1 次查询压力。**

**`Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool)`**

- **`key`**: 请求的唯一标识符。对相同 `key`的并发调用会被合并。
- **`fn`**: 真正要执行的函数，例如从数据库查询数据的逻辑。
- **返回值**:
    - `v`: 函数 `fn`返回的结果。
    - `err`: 函数 `fn`返回的错误。
    - `shared`: 一个非常重要的标志。如果为 `true`，表示这个调用的结果被多个调用者共享；如果为 `false`，表示这个调用是唯一的，没有其他调用者在等待它的结果。


**`DoChan(key string, fn func() (interface{}, error)) <-chan Result`**

- 与 `Do`功能相同，但返回一个 Channel（类型为 `<-chan Result`）。
- `Result`是一个结构体，包含 `Val`, `Err`, `Shared`字段，与 `Do`的返回值对应。
- 优势：`DoChan`可以结合 `select`语句实现超时控制或主动取消。


**`Forget(key string)`**

- 该方法告诉 `Group`，忘记一个 Key 当前正在执行或已完成的调用。
- 使用场景：当某次调用失败（比如从数据库没查到数据），你可能希望后续的请求重新尝试，而不是一直共享这个错误的结果。这时可以在错误处理逻辑中调用 `Forget`。